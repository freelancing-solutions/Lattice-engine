Perfect continuation point.
You’ve just anchored your agent ecosystem with **R-001**, which forces every plan to exist as a GitHub Issue.
Now, to build a traceable development pipeline, we extend the logic downstream with **R-002** — the rule that binds every **execution**, **branch**, and **commit** to its originating plan.

---

### **Rule: Execution Tasks Must Reference Their Originating Planning Issue**

**Identifier:** `R-002: Execution-PlanLinkIntegrity`

**Purpose:**
To ensure every code-generation, mutation, or implementation task initiated by an agent directly references the GitHub Issue that authorized it.
This maintains traceability from planning → execution → commit → deployment, creating an unbroken “reasoning chain.”

---

#### **Definitions**

* **Execution Task:**
  Any operation where an agent generates, mutates, commits, or deploys code artifacts. Includes pull request creation, feature branch initialization, and model-driven code synthesis.

* **Planning Issue ID:**
  The unique `issue.id` returned from the MCP `github.issues.create` command under Rule `R-001`.

---

#### **Rule Statement**

1. **Linkage Requirement:**
   Every execution context **must** include a valid `planning_issue_id` that maps to an existing GitHub Issue under the repository defined for the current project.

2. **Branch Creation:**
   When creating a new branch, the agent must name or tag the branch with the issue identifier.
   Examples:

   ```
   feature/issue-231-refactor-login
   fix/issue-145-cleanup-db-model
   ```

   or, if the VCS naming policy differs, embed the issue ID in metadata using `git notes` or commit trailer lines.

3. **Commit Metadata Enforcement:**
   Every commit generated by an agent **must** include the following trailer in its commit message:

   ```
   Related-Issue: #<issue-number>
   Agent-Role: <role-name>
   ```

   Example:

   ```
   Implemented new session middleware for persistent auth
   Related-Issue: #112
   Agent-Role: executor
   ```

4. **Pull Requests:**
   Pull requests **must** reference the same GitHub Issue ID in their description or title, and should automatically post a comment to the originating issue:

   ```
   github.issues.comment
   ```

   Comment body:

   > “Pull Request [#PR_NUMBER] created by [AGENT_ROLE]. Linked to this planning session.”

5. **Cross-Agent Enforcement:**
   If any agent (executor, reviewer, or deployer) receives an instruction without a `planning_issue_id` in its context, it **must** suspend the task and call:

   ```
   github.issues.comment
   ```

   to report:

   > “⚠️ Policy Violation (R-002): Missing Planning Issue ID. Execution halted.”

6. **Audit and Verification:**
   The supervisory controller periodically verifies the linkage chain:

   * `Issue → Branch → PR → Commit(s)`
     using MCP queries (`github.repos.list_branches`, `github.pulls.list`, etc.).
     If a commit or PR lacks a valid chain, the system marks it **non-compliant** and flags the agent for review.

---

#### **Rationale**

This rule ensures **lineage accountability** — every line of code can be traced to a conversation, plan, or rationale.
It also enables reproducibility: future agents (or humans) can regenerate reasoning context by fetching the linked issue.
In effect, you get a graph of “why” for every change, not just “what” changed.

---

#### **Implementation Notes**

In your agent environment:

```python
def verify_execution_context(context):
    if not context.get("planning_issue_id"):
        github_mcp.comment_issue(
            issue_id=context.get("last_issue_id"),
            body="⚠️ Policy Violation (R-002): Missing Planning Issue ID. Execution halted."
        )
        raise PolicyViolation("Execution requires linked planning issue.")
```

A `.lattice/policies/agent_rules.json` update would look like:

```json
{
  "R-002": {
    "description": "All execution tasks must reference their originating planning GitHub Issue.",
    "enforced": true,
    "requires_field": "planning_issue_id",
    "commit_trailer": "Related-Issue"
  }
}
```

---

Together, `R-001` and `R-002` create a complete accountability loop:

**Idea → Issue (R-001) → Execution → Commit (R-002)**

This structure forms the backbone of a *verifiable agentic workflow graph*.
From here, you can extend the chain into **R-003**, which would cover *Review and Merge Discipline* — ensuring all pull requests undergo either a human or reviewer-agent audit that also feeds back into the same issue thread, closing the reasoning cycle.
